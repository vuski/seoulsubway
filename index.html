<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Isochrone map1 of Seoul Subway</title>    
    <script src="https://unpkg.com/delaunator@3.0.2/delaunator.min.js"></script>    
    <script src="geoLine.js"></script>
    <script src="nodeData.js"></script>
    <script src="linkData.js"></script>
    <script src="groupData.js"></script>

    <meta name="viewport" content="width=device-width, height=device-height, user-scalable=no" />

    <style type="text/css">

        html {
            min-height: 100% !important;
            width: 100%;
            height: 100%;
        }

        /* border 제거 */
        body {
            margin-left : 0;
            margin-right : 0;
            margin-top : 0;
            margin-bottom : 0;
            border: 0;
            background-color: black;
        }
        .container {
            position: relative;
        }
        /* canvas를 viewport 크기로 만들기 */
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #text {
            background-color: transparent;  /* needed because webgl-tutoraisl.css sets canvas bg color to white */
            position: absolute;
            left: 0px;
            top: 0px;
            z-index: 10;
            -webkit-text-fill-color: aliceblue;
        }
    </style>
    <script type="text/javascript">

        var gl; // A global variable for the WebGL context
      
        //https://www.geeksforgeeks.org/implementation-priority-queue-javascript/
        
        class QElement { 
            constructor(element, priority) 
            { 
                this.element = element; 
                this.priority = priority; 
            } 
        }         
        
        class PriorityQueue {         
            
            constructor() 
            { 
                this.items = []; 
            } 
        
           
            enqueue(element, priority) 
            { 
                
                var qElement = new QElement(element, priority); 
                var contain = false; 
            
                for (var i = 0; i < this.items.length; i++) { 
                    if (this.items[i].priority > qElement.priority) { 
                       
                        this.items.splice(i, 0, qElement); 
                        contain = true; 
                        break; 
                    } 
                } 
            
                if (!contain) { 
                    this.items.push(qElement); 
                } 
            } 
            dequeue() 
            {                
                if (this.isEmpty()) 
                    return "Underflow"; 
                return this.items.shift(); 
            } 
            front() 
            {                 
                if (this.isEmpty()) 
                    return "No elements in Queue"; 
                return this.items[0]; 
            } 
            rear() 
            {              
            if (this.isEmpty()) 
            return "No elements in Queue"; 
            return this.items[this.items.length - 1]; 
            } 
            isEmpty() 
            {                 
                return this.items.length == 0; 
            } 
        } 


        function ShaderVars() {
            var shader;
         
            var zscale;
            var timelimit;
            var translation;
            var originNode;
            var drawGroup;

           ShaderVars.prototype.setUniformLoc =  function () {
                this.translation = gl.getUniformLocation(this.shader, "trans");                
                this.zscale = gl.getUniformLocation(this.shader, "zscale");
                this.timelimit = gl.getUniformLocation(this.shader, "timeCriteria");
                this.originNode = gl.getUniformLocation(this.shader, "origin");
                this.drawGroup = gl.getUniformLocation(this.shader, "drawGroup");
            } 
            var posAttrLoc; 
            var colorAttrLoc; 
            var groupAttrLoc; 
            var distAttrLoc;
            var idAttrLoc;
            
        }

        function BufferObject() {
            var vbo;            
            var idxbo;
            var numObj;
            var numIndex;
        }

        function Graph() {
            var rowOffset;
            var colIndex;
            var value;
        }

        var shaderIsochrone;
        var boIsochrone;

        var shaderSbNode;
        var boSbNode

        var shaderSbLink;
        var boSbLink;

        var canvas;
        var textCanvas; 
        var ctx;

        var scrW;
        var scrH;
        var whRatio;
         
        var cenX = 954423.0;
        var cenY = 1950874.0;
        var zoomR = 1;
        var minX = cenX-10000*zoomR;
        var maxX = cenX+10000*zoomR;
        var minY;    
        var calR;
        var maxY;  
        
        var graph;
        var originNode =0;

        var drag = false;
        var oldx, oldy;
        var dx = 0, dy = 0;

        var drawGroup = 0;
        var nodeData;
        var linkData;

        function main() {

            canvas = document.getElementById("glcanvas");
            textCanvas = document.getElementById("text");
            

            gl = initWebGL(canvas);      // Initialize the GL context
            // Only continue if WebGL is available and working
            if (!gl) return;
            recalculateMaxY();

            //현재 그룹에 맞게 노드와 링크 데이터를 재정비한다.
            refreshData();              
            setCSRGraph();
            

            //isochronemap shader
            shaderIsochrone = new ShaderVars();
            boIsochrone = new BufferObject();
            shaderIsochrone.shader = getShader("isoVertex", "isoFragment");    
            shaderIsochrone.setUniformLoc();
            setIsochroneToBuffer();
               
            
            //subway station shader
            shaderSbNode = new ShaderVars();
            boSbNode = new BufferObject();
            shaderSbNode.shader = getShader("sbNodeVertex", "sbNodeFragment");
            shaderSbNode.setUniformLoc();             
            setNodeDataToBuffer();
            

            shaderSbLink = new ShaderVars();
            boSbLink = new BufferObject();
            shaderSbLink.shader = getShader("sbLinkVertex", "sbLinkFragment");
            shaderSbLink.setUniformLoc();             
            setLinkDataToBuffer();
            
            
            resize(gl.canvas);
            
            //알아서 주사율 맞춰서 조정

            textCanvas.addEventListener("mousedown", mouseDown, false);
            textCanvas.addEventListener("mouseup", mouseUp, false);
            //canvas.addEventListener("mouseout", mouseUp, false);
            textCanvas.addEventListener("mousemove", mouseMove, false);
            textCanvas.addEventListener("wheel", mouseWheel, false);

            window.addEventListener('keydown', keydown);
            

            
           
            requestAnimationFrame(render);

        }


        function render() {

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);      // Clear the color as well as the depth buffer.

            resize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            recalculateMaxY();            
            
            //gl.lineWidth(50);

            
            gl.useProgram(shaderIsochrone.shader);
            gl.uniform4f(shaderIsochrone.translation, cenX, cenY, maxX-minX, whRatio );
            gl.bindBuffer(gl.ARRAY_BUFFER, boIsochrone.vbo);
            gl.vertexAttribPointer(boIsochrone.posAttrLoc, 2, gl.FLOAT, false, 0, 0);
            gl.vertexAttribPointer(boIsochrone.distAttrLoc, 1, gl.FLOAT, false, 0, 4*2* boIsochrone.numObj);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boIsochrone.idxbo);
            gl.drawElements(gl.TRIANGLES, boIsochrone.numIndex, gl.UNSIGNED_SHORT, 0);

            gl.useProgram(shaderSbNode.shader);
            gl.uniform4f(shaderSbNode.translation, cenX, cenY, maxX-minX, whRatio );
            gl.uniform1f(shaderSbNode.originNode, originNode );
            gl.uniform1f(shaderSbNode.drawGroup, drawGroup );
            gl.bindBuffer(gl.ARRAY_BUFFER, boSbNode.vbo);
            gl.vertexAttribPointer(boSbNode.posAttrLoc, 2, gl.FLOAT, false, 0, 0);
            gl.vertexAttribPointer(boSbNode.colorAttrLoc, 3, gl.FLOAT, false, 0, 4*2* boSbNode.numObj);
            gl.vertexAttribPointer(boSbNode.groupAttrLoc, 1, gl.FLOAT, false, 0, 4*5* boSbNode.numObj);
            gl.vertexAttribPointer(boSbNode.idAttrLoc, 1, gl.FLOAT, false, 0, 4*6* boSbNode.numObj);
            gl.drawArrays(gl.POINTS, 0, boSbNode.numObj);


            gl.useProgram(shaderSbLink.shader);
            gl.uniform4f(shaderSbLink.translation, cenX, cenY, maxX-minX, whRatio );
            gl.uniform1f(shaderSbLink.drawGroup, drawGroup );
            gl.bindBuffer(gl.ARRAY_BUFFER, boSbLink.vbo);     
            gl.vertexAttribPointer(shaderSbLink.posAttrLoc, 2, gl.FLOAT, false, 0, 0);
            gl.vertexAttribPointer(shaderSbLink.colorAttrLoc, 3, gl.FLOAT, false, 0, 4*2* boSbLink.numObj);
            gl.vertexAttribPointer(shaderSbLink.groupAttrLoc, 1, gl.FLOAT, false, 0, 4*5* boSbLink.numObj);      
            gl.drawArrays(gl.LINES, 0, boSbLink.numObj);
          
           
            
            if (originNode>0) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);    
                ctx.textBaseline = "top";
                ctx.font = "50px '맑은 고딕'";        
                ctx.fillStyle = "rgba(255,255,255,1)";
                ctx.fillText(nodeData[originNode].ln+"/"+nodeData[originNode].nm, scrW/2,scrH/20);
                ctx.font = "bold 25px '맑은 고딕'";        
                ctx.fillStyle = "rgba(190,190,190,1)";
                ctx.fillText("수도권 지하철 시간 거리 지도", scrW/2,scrH/20+60);
                ctx.font = "bold 20px '맑은 고딕'";  
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("1시간 권역까지 10분 단위 색상. 회색영역은 90분,120분", scrW/2,scrH/20+90);

                ctx.textBaseline = "bottom";


                ctx.font = "30px '맑은 고딕'";  
                ctx.fillStyle = "rgba(200,200,200,1)";
                ctx.fillText(groupData[drawGroup], scrW/2,  scrH-80);
                
                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("마우스로 zoom/pan 가능 | 양쪽 화살표키로 시간대 이동",scrW/2, scrH-50); 
            }
           
            requestAnimationFrame(render);
        }


        function doSolveSSSP() {

            var startTime = new Date().getTime();
            var solution = new Float32Array(nodeData.length);
            for (var i=0 ; i<nodeData.length ; i++) solution[i] = 3600*10;            
            var timeDistance = 99999;
            solution = solveSSSP(originNode,timeDistance, graph, solution);
            var endTime = new Date().getTime();
            //console.log((endTime-startTime)+"ms");
            gl.bindBuffer(gl.ARRAY_BUFFER, boIsochrone.vbo);
            gl.bufferSubData(gl.ARRAY_BUFFER, 4 * 2 * boIsochrone.numObj, new Float32Array(solution));
        }

        function solveSSSP(startNode,timeDistance, graph, solution)  {

            var i;
            var startTime,endTime;	
            var currentNode, nextNodeId;
            var scanBegin, scanEnd;

            var currentQueue = new PriorityQueue();
            //시작점의 정보를 입력            
            solution[startNode] = 0;                       
            currentQueue.enqueue(startNode, 0.0);

            //int cnt = 0;

            while (!currentQueue.isEmpty()) {

                var currentNodeQ = currentQueue.front();
                currentNode = currentNodeQ.element;
                startTime = currentNodeQ.priority;

                scanBegin = graph.rowOffset[currentNode];
                scanEnd = graph.rowOffset[currentNode + 1];
                //console.log(scanBegin+","+scanEnd);
                for (i = scanBegin; i < scanEnd; i++) {

                    endTime = startTime + graph.value[i];
                    nextNodeId = graph.colIndex[i];
                    if (endTime < timeDistance) {

                        if (solution[nextNodeId] > endTime) {					
                            solution[nextNodeId] = endTime;                            			
                            currentQueue.enqueue(nextNodeId, endTime);
                        }
                    }
                }
                currentQueue.dequeue(); 
                
            } //while currentQueue >0            
            return solution;
        }

        function setCSRGraph() {

            graph = new Graph();
            graph.rowOffset = new Array(nodeData.length);
            graph.colIndex = new Array(linkData.length);
            graph.value = new Array(linkData.length);

            var rowIndex = 0;   

            for (var i=0; i<linkData.length ; i++) {                
                
                while (rowIndex <= linkData[i][0]) {
                    graph.rowOffset[rowIndex] = i;
                    rowIndex++;
                }
                graph.colIndex[i] = linkData[i][1];
                if (nodeData[linkData[i][0]].gr > drawGroup 
                        || nodeData[linkData[i][1]].gr > drawGroup) {
                    graph.value[i] = 36000;
                } else {
                    graph.value[i] = linkData[i][2];
                }
               
            }
            graph.rowOffset[rowIndex] = linkData.length;

        }

        
        function setIsochroneToBuffer() {

            //var startTime = new Date().getTime();
            var dpoints = new Array(nodeData.length);
            var position = new Array(nodeData.length*2);
            var distance = new Array(nodeData.length);
            for (var i=0; i<nodeData.length ; i++) {
                dpoints[i] = [nodeData[i].x, nodeData[i].y];      
                position[i*2+0] = nodeData[i].x;
                position[i*2+1] = nodeData[i].y;
                distance[i] = 999999;
            }

            const delaunay = Delaunator.from(dpoints);
            //console.log(delaunay.triangles);
            
            var triangleIndex = new Uint16Array(delaunay.triangles.length);
            for (var i=0 ; i<delaunay.triangles.length ; i++) {
                triangleIndex[i] = delaunay.triangles[i];
            }

            boIsochrone.numObj = nodeData.length;
            boIsochrone.numIndex = delaunay.triangles.length;


            boIsochrone.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boIsochrone.vbo);
            gl.bufferData(gl.ARRAY_BUFFER,  4 * 3 * boIsochrone.numObj , gl.DYNAMIC_DRAW);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(position));
            doSolveSSSP();//새로 계산해서 subData넣는다.
            //gl.bufferSubData(gl.ARRAY_BUFFER, 4 * 2 * boIsochrone.numObj, new Float32Array(distance));

            boIsochrone.posAttrLoc = gl.getAttribLocation(shaderIsochrone.shader, "pos"); 
            boIsochrone.distAttrLoc = gl.getAttribLocation(shaderIsochrone.shader, "distance"); 

            gl.enableVertexAttribArray(boIsochrone.posAttrLoc);   
            gl.enableVertexAttribArray(boIsochrone.distAttrLoc);   

            boIsochrone.idxbo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boIsochrone.idxbo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,   new Uint16Array(triangleIndex) , gl.STATIC_DRAW);
            var endTime = new Date().getTime();
            //console.log("done:"+(endTime-startTime));
        }

        function setLinkDataToBuffer() {

            var count = 0;
            for (var i=0 ; i<geoLine.length; i++) {
                count += (geoLine[i].crd.length-1)*2;
            }
            boSbLink.numObj = count;            
            //console.log(boSbLink.numObj);

            var pos = new Array(boSbLink.numObj * 2);
            var color = new Array(boSbLink.numObj * 3);
            var group = new Array(boSbLink.numObj);

            count = 0;
            var r,g,b,groupSub;
            for (var i=0 ; i<geoLine.length ; i++) {

                r = parseInt(geoLine[i].cl.substring(1,3), 16)/255.0;
                g = parseInt(geoLine[i].cl.substring(3,5), 16)/255.0;
                b =  parseInt(geoLine[i].cl.substring(5), 16)/255.0;
                groupSub = geoLine[i].gr;
                
                var coord = geoLine[i].crd;
                for (var j=0 ; j<coord.length-1 ;j++ ) {
                    pos[count*4 + 0] = coord[j][0];
                    pos[count*4 + 1] = coord[j][1];
                    pos[count*4 + 2] = coord[j+1][0];
                    pos[count*4 + 3] = coord[j+1][1];
                                
                    color[count*6 + 0] = r;
                    color[count*6 + 1] = g;
                    color[count*6 + 2] = b;
                    color[count*6 + 3] = r;
                    color[count*6 + 4] = g;
                    color[count*6 + 5] = b;
                    //console.log(color[count*6]);
                    group[count*2] = groupSub;
                    group[count*2+1] = groupSub;
                   
                    count++;
                    //console.log(nodeData[i]);
                    //console.log((pos[i*2]-cenX)/(maxX-minX));
                    //console.log(color[i*3 + 0]+","+color[i*3 + 1]+","+color[i*3 + 2]);
                }
                
            }
            
            boSbLink.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boSbLink.vbo);

            gl.bufferData(gl.ARRAY_BUFFER, 4*6*boSbLink.numObj , gl.STATIC_DRAW);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(pos));
            gl.bufferSubData(gl.ARRAY_BUFFER, 4*2* boSbLink.numObj, new Float32Array(color));
            gl.bufferSubData(gl.ARRAY_BUFFER, 4*5* boSbLink.numObj, new Float32Array(group));

            shaderSbLink.posAttrLoc = gl.getAttribLocation(shaderSbLink.shader, "pos"); 
            shaderSbLink.colorAttrLoc = gl.getAttribLocation(shaderSbLink.shader, "color"); 
            shaderSbLink.groupAttrLoc = gl.getAttribLocation(shaderSbLink.shader, "grpclass"); 

            gl.enableVertexAttribArray(shaderSbLink.posAttrLoc);   
            gl.enableVertexAttribArray(shaderSbLink.colorAttrLoc);   
            gl.enableVertexAttribArray(shaderSbLink.groupAttrLoc);  
            
        }


        function setNodeDataToBuffer() {

            boSbNode.numObj = nodeDataRaw.length;
            //console.log(boSbNode.numObj);
            var pos = new Array(boSbNode.numObj * 2);
            var color = new Array(boSbNode.numObj * 3);
            var group = new Array(boSbNode.numObj);
            var id = new Array(boSbNode.numObj);

            for (var i=0 ; i<boSbNode.numObj ; i++) {

                pos[i*2 + 0] = nodeDataRaw[i].x;
                pos[i*2 + 1] = nodeDataRaw[i].y;
                            
                color[i*3 + 0] = parseInt(nodeDataRaw[i].cl.substring(1,3), 16)/255.0;
                color[i*3 + 1] = parseInt(nodeDataRaw[i].cl.substring(3,5), 16)/255.0;
                color[i*3 + 2] = parseInt(nodeDataRaw[i].cl.substring(5), 16)/255.0;
               
                group[i] = nodeDataRaw[i].gr;
                id[i] = nodeDataRaw[i].no;
                
            }

            boSbNode.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boSbNode.vbo);

            gl.bufferData(gl.ARRAY_BUFFER, 4*7*boSbNode.numObj , gl.STATIC_DRAW);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(pos));
            gl.bufferSubData(gl.ARRAY_BUFFER, 4*2* boSbNode.numObj, new Float32Array(color));
            gl.bufferSubData(gl.ARRAY_BUFFER, 4*5* boSbNode.numObj, new Float32Array(group));
            gl.bufferSubData(gl.ARRAY_BUFFER, 4*6* boSbNode.numObj, new Float32Array(id));

            boSbNode.posAttrLoc = gl.getAttribLocation(shaderSbNode.shader, "pos"); 
            boSbNode.colorAttrLoc = gl.getAttribLocation(shaderSbNode.shader, "color"); 
            boSbNode.groupAttrLoc = gl.getAttribLocation(shaderSbNode.shader, "grpclass"); 
            boSbNode.idAttrLoc = gl.getAttribLocation(shaderSbNode.shader, "nodeId"); 

            gl.enableVertexAttribArray(boSbNode.posAttrLoc);   
            gl.enableVertexAttribArray(boSbNode.colorAttrLoc);   
            gl.enableVertexAttribArray(boSbNode.groupAttrLoc);  
            gl.enableVertexAttribArray(boSbNode.idAttrLoc);  
        }


      
        function initWebGL(canvas) {
            gl = null;

            try {
                // Try to grab the standard context. If it fails, fallback to experimental.
                gl = canvas.getContext("webgl")|| canvas.getContext("experimental-webgl");
            }
            catch (e) { }

            // If we don't have a GL context, give up now
            if (!gl) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                gl = null;
            }


            resize(gl.canvas);
            gl.viewport(0, 0, scrW, scrH);
            gl.clearColor(0.0, 0.0, 0.0, 1.0); 
            gl.enable(gl.DEPTH_TEST);  
            gl.depthFunc(gl.LEQUAL); 
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.getExtension('OES_standard_derivatives');
            //gl.getExtension('OES_element_index_uint');
            return gl;
        }

        function getShader(vertexName, fragmentName) {

            var vertexShaderSource = document.getElementById(vertexName).text;
            var fragmentShaderSource = document.getElementById(fragmentName).text;

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.shaderSource(fragmentShader, fragmentShaderSource);

            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                alert("Error compiling vertex shader : " + gl.getShaderInfoLog(vertexShader));                    
                gl.deleteShader(vertexShader);
                return null;
            }

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                alert("Error compiling fragment shader : " + gl.getShaderInfoLog(fragmentShader));                    
                gl.deleteShader(fragmentShader);
                return null;
            }

            var shaderProgram = gl.createProgram();

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);

            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Failed to link shaders");                   
                gl.deleteProgram(shaderProgram);
                return null;
            }
            return shaderProgram;
        }


        function refreshData() {

            var nodeDataMatcher = new Array(nodeDataRaw.length);
            for (var i=0 ; i<nodeDataRaw.length ; i++) nodeDataMatcher[i] = -1;

            var counter =0;
            for (var i=0 ; i<nodeDataRaw.length ; i++) {
                if (nodeDataRaw[i].gr <= drawGroup) {
                    nodeDataMatcher[i] = counter;
                    counter++;                
                }
            }
            nodeData = new Array(counter);
            counter = 0;
            for (var i=0 ; i<linkDataRaw.length ; i++) {
                if (nodeDataRaw[linkDataRaw[i][0]].gr<=drawGroup 
                    && nodeDataRaw[linkDataRaw[i][1]].gr<=drawGroup ) counter++;   
            }
            linkData = new Array(counter);

            counter = 0;
            for (var i=0 ; i<nodeDataRaw.length ; i++) {
                if (nodeDataMatcher[i] != -1) {
                    nodeData[counter] = nodeDataRaw[i];
                    nodeData[counter].no = counter;
                    counter++;
                }
            }

            counter = 0;
            for (var i=0 ; i<linkDataRaw.length ; i++) {
                if (nodeDataRaw[linkDataRaw[i][0]].gr<=drawGroup 
                    && nodeDataRaw[linkDataRaw[i][1]].gr<=drawGroup ) {
                        linkData[counter] = new Array(3);
                        linkData[counter][0] = nodeDataMatcher[linkDataRaw[i][0]];
                        linkData[counter][1] = nodeDataMatcher[linkDataRaw[i][1]];
                        linkData[counter][2] = linkDataRaw[i][2];
                        counter++;
                   
                }
            }


        }

        function resize(canvas) {
            // 브라우저에서 canvas가 표시되는 크기 탐색
            var displayWidth = canvas.clientWidth;
            var displayHeight = canvas.clientHeight;

            // canvas가 같은 크기가 아닐 때 확인
            if (canvas.width != displayWidth ||
                canvas.height != displayHeight) {

                // canvas를 동일한 크기로 수정
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                textCanvas.width = displayWidth;
                textCanvas.height = displayHeight;
            }
            ctx = textCanvas.getContext("2d");
            
            ctx.textAlign = 'center';
            ctx.fillStyle = "rgba(255,255,255,1)";
            ctx.textBaseline = "top";

            
        }

        function recalculateMaxY() {

            scrW = canvas.width;
            scrH = canvas.height;
            minX = cenX-10000*zoomR;
            maxX = cenX+10000*zoomR;
            calR = (maxX - minX) / scrW;
            maxY = cenY +(scrH *calR/2);
            minY = cenY -(scrH *calR/2);            
            whRatio = scrW / scrH ;            
            //console.log(scrW+","+scrH+","+cenX+","+cenY+","+calR+","+whRatio);
        }

        
        //justmove
        function mouseMove(e) {
            if (drag) {
                //console.log(e.pageX+","+e.pageY);
                dx = (e.pageX - oldx)*calR*2;
                dy = (e.pageY - oldy)*calR*2;
                cenX = cenX - dx;
                cenY = cenY + dy;               
                //console.log(dx*calR +","+dy*calR);
                oldx = e.pageX, oldy = e.pageY;
                e.preventDefault();
            } else {
                recalculateMaxY();
                var mx = (e.pageX-scrW/2)/(scrW/2)*(maxX-minX)+cenX;
                var my = -(e.pageY-scrH/2)/(scrH/2)/whRatio*(maxX-minX)+cenY;
                //console.log(mx+","+my);
                originNode = getNearestStation(mx, my);               
                if (originNode != -1) { //10km 안쪽의 점을 찾으면
                    doSolveSSSP();
                }   
            }
            //console.log(e.pageX +"." + e.pageY);
            //console.log(1);
        }

        function mouseDown(e) {
            drag = true;
            oldx = e.pageX, oldy = e.pageY;
            e.preventDefault();
            return false;
        }

        function mouseUp(e) {
            drag = false;
        }

        function mouseWheel(e) {

            var zoomRCheck = zoomR * ( e.deltaY>0? 1+0.3*e.deltaY/100 : 1+0.2307692*e.deltaY/100);
            if (zoomRCheck < 0.1 || zoomRCheck > 7.0) return;               
           
            zoomR = zoomRCheck;
            cenX -= e.deltaY>0? (maxX-minX)*(e.pageX-scrW/2)/(scrW/2)*0.3*e.deltaY/100
                                : (maxX-minX)*(e.pageX-scrW/2)/(scrW/2)*0.2307692*e.deltaY/100;
            cenY += e.deltaY>0? (maxX-minX)/whRatio*(e.pageY-scrH/2)/(scrH/2)*0.3*e.deltaY/100
                                : (maxX-minX)/whRatio*(e.pageY-scrH/2)/(scrH/2)*0.2307692*e.deltaY/100;     
           
            //console.log(e.deltaX+","+e.deltaY);
        }
        

        function keydown(e) {

            //console.log("keyCode :"+e.keyCode);
            switch(e.keyCode) {

              case 37: //left arrow
                if (drawGroup==0) drawGroup = 21;
                else drawGroup--;
                refreshData();
                setCSRGraph();
                setIsochroneToBuffer();                               
                console.log(drawGroup);
                break;
              case 39: //right arrow
                if (drawGroup==21) drawGroup = 0;
                else drawGroup++;
                refreshData();
                setCSRGraph();
                setIsochroneToBuffer();                            
                console.log(drawGroup);
                break;
            }
            e.preventDefault();

        }

       
        

        function getNearestStation(mx, my) {

            var origin = -1;
            var nearestDist = 10000;
            var x,y, dist;
            for (var i=0 ; i<nodeData.length ; i++) {
                x = nodeData[i].x;
                y = nodeData[i].y;
                dist = Math.sqrt((mx-x)*(mx-x)+(my-y)*(my-y));
                if (dist<nearestDist) {
                    nearestDist = dist;
                    origin = nodeData[i].no;
                }
            }
            return origin;
        }



    </script>

    <script id="isoVertex" type="notjs">
        attribute vec2 pos;
        attribute float distance;  
        
        uniform vec4 trans;

        varying float dist;

        void main() {
       
            vec2 position = (pos-trans.xy)/trans.z;           
            gl_Position =  vec4(position.x , position.y *trans.w, 0,1.0);    
               
            dist = distance;
        }

    </script>

    <script id="isoFragment" type="notjs">

        precision highp float;

        varying float dist;
        float alpha = 0.6;
        void main() {
            
            float timeCriteria = 600.0;

            if (dist<timeCriteria) {
                gl_FragColor = vec4(0, 0, 0.0156, alpha);
            } else if (dist<timeCriteria*2.0) {
                gl_FragColor = vec4(0.169, 0.058, 0.431, alpha);
            } else if (dist<timeCriteria*3.0) {
                gl_FragColor = vec4(0.537254902,	0.156862745,	0.505882353 , alpha);
            } else if (dist<timeCriteria*4.0) {
                gl_FragColor = vec4(0.878431373,	0.298039216,	0.403921569, alpha);
            } else if (dist<timeCriteria*5.0) {
                gl_FragColor = vec4(0.996078431,	0.631372549,	0.431372549,  alpha);
            } else if (dist<timeCriteria*6.0) {
                gl_FragColor = vec4(0.988235294,	0.992156863,	0.749019608,  alpha);    
            } else if (dist<timeCriteria*9.0) {
                gl_FragColor = vec4(0.7,	0.7,	0.7,  alpha-0.3);    
            } else if (dist<timeCriteria*12.0) {
                gl_FragColor = vec4(0.7,	0.7,	0.7,  alpha-0.4);    
            }else {
                discard;
            }
        
        }

    </script>

    <script id="sbNodeVertex" type="notjs">
        
        precision highp float;
        attribute vec2 pos;
        attribute vec3 color;
        attribute float grpclass;
        attribute float nodeId;

        uniform vec4 trans;
        uniform float origin;
       

        varying vec3 col1;
        varying float grp;
        
        void main() {
            
            vec2 position = (pos-trans.xy)/trans.z;
            if (nodeId==origin) gl_PointSize = 20.0;
            else    gl_PointSize = 5.0;
            gl_Position =  vec4(position.x , position.y *trans.w, 0,1.0); 
            col1 = color;
            grp = grpclass;
        }

    </script>

    <script id="sbNodeFragment" type="notjs">
        
        #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
        #endif
        precision highp float;

        uniform float drawGroup;

        varying vec3 col1;
        varying float grp;
      

        void main() {
          
            if (grp > drawGroup) {
                discard;
            } else {
                float r = 0.0, delta = 0.0, alpha = 1.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);
            #ifdef GL_OES_standard_derivatives
                delta = fwidth(r);
                alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
            #endif
                if (grp > -1.0 ) {
                    gl_FragColor = vec4(col1,1) *alpha;
                } else {
                    discard;
                }
            }
        }

    </script>
    <script id="sbLinkVertex" type="notjs">
        
        precision highp float;
        attribute vec2 pos;
        attribute vec3 color;
        attribute float grpclass;

        uniform vec4 trans;
 

        varying vec3 col1;
        varying float grp;

        void main() {
           
            vec2 position = (pos-trans.xy)/trans.z;          
            gl_Position =  vec4(position.x , position.y *trans.w, 0,1.0);   
            
            col1 = color;
            grp = grpclass;
        }
       

    </script>

    <script id="sbLinkFragment" type="notjs">
       
        precision highp float;

        uniform float drawGroup;

        varying vec3 col1;
        varying float grp;

        void main() {
            if (grp > drawGroup ) {
                discard;
            } else {            
                if (grp > -1.0 ) {
                    gl_FragColor = vec4(col1,1);
                } else {
                    discard;
                }
            }
         
        }

    </script>
</head>
<body onload="main()">
    <canvas id="glcanvas"></canvas>    
    <canvas id="text"></canvas>
</body>
</html>